mean(z)
z-mean(z)
max(z)-mean(z)
?cov
z[1]=8.2
cov(f,z)
max(z)-mean(z)
nAgents=100;spendEnergy=9;maxEnergy=100;resourceGrowthRate=2;#
               timeSteps=1000;xDim=30;yDim=30;memory=FALSE;#
               decisionType=c("greedy");#
plot=TRUE;verbose=TRUE
nAgents=100;energyCost=9;maxEnergy=100;resourceGrowthRate=2;#
               timeSteps=1000;dimX=30;dimY=30;memory=FALSE;#
               decisionType=c("greedy");#
plot=TRUE;verbose=TRUE
population=numeric() #placeholder for recording population size #
        resource=matrix(round(runif(dimX*dimY,0,maxEnergy)),nrow=dimX,ncol=dimY) #initialise resource scape
image(resource)
maxResource=resource #maximum possible resource value per cell
maxResource
memory==TRUE
memory=TRUE
cognitiveMaps=vector("list",length=nAgents)
cognitiveMaps
for (x in 1:nAgents){cognitiveMaps[[x]]=matrix(NA,nrow=dimX,ncol=dimY)}
cognitiveMaps
newOrder=sample(1:nrow(agents))
agents=data.frame(energy=rep(maxEnergy/2,nAgents),x=ceiling(runif(nAgents,0,dimX)),y=ceiling(runif(nAgents,0,dimX)))
newOrder=sample(1:nrow(agents))
newOrder
agents=agents[newOrder,]  #shuffle agent order
cognitiveMaps=cognitiveMaps[newOrder]
a=1
agenta[1,]
agents[1,]
neighbourhood(xcor=agents[a,2],ycor=agents[a,3],#
                                                  xLimit=c(1,dimX),yLimit=c(1,dimY),#
                                                  resourceMatrix=resource,type=decisionType)
neighbourhood<-function(xcor,ycor,xLimit,yLimit,resourceMatrix,type=c("greedy","probabilistic"))#
{#
step=c(-1,0,1)#
xcor1=xcor+step#
ycor1=ycor+step#
address=expand.grid(x=xcor1,y=ycor1)#
if(sum((address$x<xLimit[1]|address$x>xLimit[2]),na.rm=TRUE)>0){address[which(address$x<xLimit[1]|address$x>xLimit[2]),]=NA}#
if(sum((address$y<yLimit[1]|address$y>yLimit[2]),na.rm=TRUE)>0){address[which(address$y<yLimit[1]|address$y>yLimit[2]),]=NA}#
destinationResource=apply(address,1,function(x,y){#
    if(!is.na(x[1]))#
        {return(y[x[1],x[2]])}#
    if(is.na(x[1]))#
        return(NA)},y=resourceMatrix)#
if(type=="greedy")#
    {#
        goto=which(destinationResource==max(destinationResource,na.rm=TRUE))#
        if(length(goto)>1){goto=sample(goto,size=1)}#
        finaladdress=address[goto,]#
    }#
if(type=="probabilistic")#
    {#
        destinationResource[which(is.na(destinationResource))]=0#
        goto=sample(1:9,size=1,prob=destinationResource)#
        if(length(goto)>1){goto=sample(goto,size=1)}#
        finaladdress=address[goto,]#
    }#
return(finaladdress)#
}
neighbourhood(xcor=agents[a,2],ycor=agents[a,3],#
                                                  xLimit=c(1,dimX),yLimit=c(1,dimY),#
                                                  resourceMatrix=resource,type=decisionType)
neighbourhood(xcor=agents[a,2],ycor=agents[a,3],#
                                                  xLimit=c(1,dimX),yLimit=c(1,dimY),#
                                                  resourceMatrix=resource,type="probabilistic")
f=c(1,rep(0,10))
f
z=c(10,rnorm(10,5,2))
z
cov(z,f)
cov(f,z)
max(z)-mean(z)
mu=2#
lambda=2#
y=rnorm(10,mean=2,sd=1)#
epsilon=rnorm(10,mean=0,sd=0.5)#
#
z=mu+lambda*y+epsilon
z
mu=2#
lambda=2#
y=rnorm(10,mean=2,sd=1)#
epsilon=rnorm(10,mean=0,sd=0.5)#
#
z=mu+lambda*y+epsilon#
m=5#
rho=0.4#
e=rnorm(mean=10,sd=1)#
#
f=m+rho*y+e
mu=2#
lambda=2#
y=rnorm(10,mean=2,sd=1)#
epsilon=rnorm(10,mean=0,sd=0.5)#
#
z=mu+lambda*y+epsilon#
m=5#
rho=0.4#
e=rnorm(10,mean=0,sd=1)#
#
f=m+rho*y+e
f
y
cov(f,y)
rho*(cov(z,y))
cov(f,y)#
#
rho*(cov(z,y))#
lambda*rho*var(y)
mu=2#
lambda=2#
y=rnorm(10,mean=2,sd=1)#
epsilon=rnorm(10,mean=0,sd=0.5)#
#
z=mu+lambda*y+epsilon#
m=5#
rho=0.4#
e=rnorm(10,mean=0,sd=1)#
#
f=m+rho*y+e#
#
cov(f,y)#
rho*(cov(z,y))#
lambda*rho*var(y)
mu=2#
lambda=2#
y=rnorm(10,mean=2,sd=1)#
epsilon=rnorm(10,mean=0,sd=0.5)#
#
z=mu+lambda*y+epsilon#
m=5#
rho=1#
e=rnorm(10,mean=0,sd=1)#
#
f=m+rho*y+e#
#
cov(f,y)#
rho*(cov(z,y))#
lambda*rho*var(y)
mu=2#
lambda=2#
y=rnorm(10,mean=2,sd=1)#
epsilon=rnorm(10,mean=0,sd=0.5)#
#
z=mu+lambda*y+epsilon#
m=5#
rho=0.2#
e=rnorm(10,mean=0,sd=1)#
#
f=m+rho*y+e#
#
cov(f,y)#
rho*(cov(z,y))#
lambda*rho*var(y)
sample(1:9,prob=c(0,0,0,0,0,0,0,0,0,))
sample(1:9,prob=c(0,0,0,0,0,0,0,0,0))
sample(1:9,prob=c(0,0,0,0,0,0,0,0,0)+1)
sample(1:9,prob=c(0,0,0,0,0,0,0,0,0))
sample(size=1,1:9,prob=c(0,0,0,0,0,0,0,0,0))
source('~/Documents/Imago Mundi/Works in Progress/github/culturalIncubators/culturalincubators/src/SpatialModel.R', chdir = TRUE)
N=1000#
x<-runif(N)#
y<-runif(N)#
distMatrix<-as.matrix(dist(cbind(x,y)))#
plot(x~y,pch=20,col=rgb(0,0,0,0.1),xlab="x",ylab="y")
locations=data.frame(id=1:N,x=x,y=y)
locations
i=subset(locations,x>0.35&x<0.45&y>0.35&y<0.45)
i
distMatrix[i$id[1],]
neighbours=matrixGenerator(distMatrix=distMatrix,k=20)
neighbours
neighbours[i,]
neighbours[i$id[1],]
pool=which(as.boolean(neighbours[i$id[1],]))
pool=which(as.logical(neighbours[i$id[1],]))
pool
pool=which(neighbours[i$id[1],])==1)
pool=which(neighbours[i$id[1],]==1)
pool
i=subset(locations,x>0.35&x<0.45&y>0.35&y<0.45)$id[1]
ui
i
pool=which(neighbours[i,]==1)
pool
plot(x[i],y[i],pch=20,col="red",ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")
pool.i=which(neighbours[i,]==1)
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.5))
N=1000#
k=40#
x<-runif(N)#
y<-runif(N)#
distMatrix<-as.matrix(dist(cbind(x,y)))#
locations=data.frame(id=1:N,x=x,y=y)#
#
plot(x~y,pch=20,col="lightgrey",xlab="x",ylab="y")#
neighbours=matrixGenerator(distMatrix=distMatrix,k=20)#
#agent i#
i=subset(locations,x>0.35&x<0.45&y>0.35&y<0.45)$id[1]#
pool.i=which(neighbours[i,]==1)#
#
plot(x[i],y[i],pch=20,col="red",ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.1))
N=1000#
k=100#
x<-runif(N)#
y<-runif(N)#
distMatrix<-as.matrix(dist(cbind(x,y)))#
locations=data.frame(id=1:N,x=x,y=y)#
#
plot(x~y,pch=20,col="lightgrey",xlab="x",ylab="y")#
neighbours=matrixGenerator(distMatrix=distMatrix,k=20)#
#agent i#
i=subset(locations,x>0.35&x<0.45&y>0.35&y<0.45)$id[1]#
pool.i=which(neighbours[i,]==1)#
#
plot(x[i],y[i],pch=20,col="red",ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.1))
N=1000#
k=100#
x<-runif(N)#
y<-runif(N)#
distMatrix<-as.matrix(dist(cbind(x,y)))#
locations=data.frame(id=1:N,x=x,y=y)#
#
plot(x~y,pch=20,col="lightgrey",xlab="x",ylab="y")#
neighbours=matrixGenerator(distMatrix=distMatrix,k=k)#
#agent i#
i=subset(locations,x>0.35&x<0.45&y>0.35&y<0.45)$id[1]#
pool.i=which(neighbours[i,]==1)#
#
plot(x[i],y[i],pch=20,col="red",ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.1))
j=subset(locations,x>0.45&x<0.65&y>0.45&y<0.65)$id[1]
pool.j=which(neighbours[j,]==1)
points(x[j],y[j],pch=20,col=rgb(0,0,1,1))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.1))
plot(x[i],y[i],pch=5,col="red",ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.1))#
#
#agent j#
j=subset(locations,x>0.40&x<0.60&y>0.40&y<0.60)$id[1]#
pool.j=which(neighbours[j,]==1)#
#
points(x[j],y[j],pch=5,col=rgb(0,0,1,1))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.1))
plot(x[i],y[i],pch=6,col="red",ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.1))#
#
#agent j#
j=subset(locations,x>0.40&x<0.60&y>0.40&y<0.60)$id[1]#
pool.j=which(neighbours[j,]==1)#
#
points(x[j],y[j],pch=6,col=rgb(0,0,1,1))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.1))
plot(x[i],y[i],pch=19,col="red",ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.1))#
#
#agent j#
j=subset(locations,x>0.40&x<0.60&y>0.40&y<0.60)$id[1]#
pool.j=which(neighbours[j,]==1)#
#
points(x[j],y[j],pch=19,col=rgb(0,0,1,1))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.1))
#agent i#
i=subset(locations,x>0.35&x<0.45&y>0.35&y<0.45)$id[1]#
pool.i=which(neighbours[i,]==1)#
#
plot(x[i],y[i],pch=19,col="red",ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.1))#
#
#agent j#
j=subset(locations,x>0.45&x<0.65&y>0.40&y<0.60)$id[1]#
pool.j=which(neighbours[j,]==1)#
#
points(x[j],y[j],pch=19,col=rgb(0,0,1,1))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.1))
#agent i#
i=subset(locations,x>0.35&x<0.45&y>0.35&y<0.45)$id[1]#
pool.i=which(neighbours[i,]==1)#
#
plot(x[i],y[i],pch=19,col="red",ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.2))#
#
#agent j#
j=subset(locations,x>0.45&x<0.65&y>0.40&y<0.60)$id[1]#
pool.j=which(neighbours[j,]==1)#
#
points(x[j],y[j],pch=19,col=rgb(0,0,1,1))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.2))
neighbours[c(i,j),]
shared.pool=which(apply(neighbours[c(i,j),],2,sum)==2)
shared.pool
pool.j=which(neighbours[j,]==1)
pool.j
pool.j=pool.j[-which(pool.j%in%shared.pool)]
pool.i=pool.i[-which(pool.i%in%shared.pool)]
i=subset(locations,x>0.35&x<0.45&y>0.35&y<0.45)$id[1]#
j=subset(locations,x>0.45&x<0.65&y>0.40&y<0.60)$id[1]#
#
shared.pool=which(apply(neighbours[c(i,j),],2,sum)==2)#
pool.j=which(neighbours[j,]==1)#
pool.j=pool.j[-which(pool.j%in%shared.pool)]#
pool.i=which(neighbours[i,]==1)#
pool.i=pool.i[-which(pool.i%in%shared.pool)]#
#Plot Self#
plot(x[i],y[i],pch=19,col="red",ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[j],y[j],pch=19,col=rgb(0,0,1,1))#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.5))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.5))#
points(x[shared.pool],y[shared.pool,pch=20,col=rgb(0,1,0,0.5))
points(x[shared.pool],y[shared.pool],pch=20,col=rgb(0,1,0,0.5))
#Plot Self#
plot(x[i],y[i],pch=19,col="red",ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[j],y[j],pch=19,col=rgb(0,0,1,1))#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.1))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.1))#
points(x[shared.pool],y[shared.pool],pch=20,col=rgb(0,1,0,0.1))
#Plot Self#
plot(x[i],y[i],pch=19,col="red",ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[j],y[j],pch=19,col=rgb(0,0,1,1))#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.2))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.2))#
points(x[shared.pool],y[shared.pool],pch=20,col=rgb(0,1,0,0.2))
rest=1:N[-c(pool.j,pool.i,shared.pool)]
rest=c(1:N)[-c(pool.j,pool.i,shared.pool)]
rest
i=subset(locations,x>0.35&x<0.45&y>0.35&y<0.45)$id[1]#
j=subset(locations,x>0.45&x<0.65&y>0.40&y<0.60)$id[1]#
#
shared.pool=which(apply(neighbours[c(i,j),],2,sum)==2)#
pool.j=which(neighbours[j,]==1)#
pool.j=pool.j[-which(pool.j%in%shared.pool)]#
pool.i=which(neighbours[i,]==1)#
pool.i=pool.i[-which(pool.i%in%shared.pool)]#
rest=c(1:N)[-c(pool.j,pool.i,shared.pool)]#
plot(x[rest],y[res],pch=20,col=rgb(0,0,0,0.2),ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[i],y[i],pch=19,col="red")#
points(x[j],y[j],pch=19,col=rgb(0,0,1,1))#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.2))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.2))#
points(x[shared.pool],y[shared.pool],pch=20,col=rgb(0,1,0,0.2))#
points(x[rest],y[res],pch=20,col=rgb(0,0,0,0.2))
plot(x[rest],y[rest],pch=20,col=rgb(0,0,0,0.2),ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[i],y[i],pch=19,col="red")#
points(x[j],y[j],pch=19,col=rgb(0,0,1,1))#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.2))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.2))#
points(x[shared.pool],y[shared.pool],pch=20,col=rgb(0,1,0,0.2))#
points(x[rest],y[res],pch=20,col=rgb(0,0,0,0.2))
plot(x[rest],y[rest],pch=20,col=rgb(0,0,0,0.1),ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[i],y[i],pch=19,col="red")#
points(x[j],y[j],pch=19,col=rgb(0,0,1,1))#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.2))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.2))#
points(x[shared.pool],y[shared.pool],pch=20,col=rgb(0,1,0,0.2))#
points(x[rest],y[res],pch=20,col=rgb(0,0,0,0.2))
plot(x[rest],y[rest],pch=20,col=rgb(0,0,0,0.05),ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[i],y[i],pch=19,col="red")#
points(x[j],y[j],pch=19,col=rgb(0,0,1,1))#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.2))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.2))#
points(x[shared.pool],y[shared.pool],pch=20,col=rgb(0,1,0,0.2))#
points(x[rest],y[res],pch=20,col=rgb(0,0,0,0.2))
plot(x[rest],y[rest],pch=20,col=rgb(0,0,0,0.05),ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[i],y[i],pch=21,col="red")#
points(x[j],y[j],pch=21,col=rgb(0,0,1,1))#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.2))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.2))#
points(x[shared.pool],y[shared.pool],pch=20,col=rgb(0,1,0,0.2))#
points(x[rest],y[res],pch=20,col=rgb(0,0,0,0.2))
plot(x[rest],y[rest],pch=20,col=rgb(0,0,0,0.05),ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[i],y[i],pch=22,col="red")#
points(x[j],y[j],pch=22,col=rgb(0,0,1,1))#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.2))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.2))#
points(x[shared.pool],y[shared.pool],pch=20,col=rgb(0,1,0,0.2))#
points(x[rest],y[res],pch=20,col=rgb(0,0,0,0.2))
plot(x[rest],y[rest],pch=20,col=rgb(0,0,0,0.05),ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[i],y[i],pch=23,col="red")#
points(x[j],y[j],pch=23,col=rgb(0,0,1,1))#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.2))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.2))#
points(x[shared.pool],y[shared.pool],pch=20,col=rgb(0,1,0,0.2))#
points(x[rest],y[res],pch=20,col=rgb(0,0,0,0.2))
plot(x[rest],y[rest],pch=20,col=rgb(0,0,0,0.05),ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[i],y[i],pch=15,col="red")#
points(x[j],y[j],pch=15,col=rgb(0,0,1,1))#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.2))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.2))#
points(x[shared.pool],y[shared.pool],pch=20,col=rgb(0,1,0,0.2))
~/Documents/Imago Mundi/Works in Progress/github/culturalIncubators/culturalincubators/figures/testFigures
dev.print(device=pdf,"~/Documents/Imago Mundi/Works in Progress/github/culturalIncubators/culturalincubators/figures/testFiguresfigSpatial.pdf")
data=read.csv("~/Documents/Imago Mundi/Works in Progress/EcologyandSocietyPaper/fromLegion/experiment2Complete.csv")
data[1:10,]
################################################################
# ~Decision Making Model~#
# by enrico.crema@gmail.com                                      #
#                                        #
# Parameters:                                       #
# decisionType ::: Type of decision, either "greedy" or "probabilistic"#
# memory ::: Boolean, whether the agents move based on current state of the system, or their cognitive maps#
# dimX ::: x limit of the world#
# dimY ::: y limit of the world#
# nAgents ::: Number of agents at initialisation                                        #
# nSteps ::: Number of timesteps in the model#
# resourceGrowthRate ::: Amount increase of resources per timeStep#
# maxEnergy ::: maximum possible storable energy. Also maximum possible cell values in the resource scape. #
# energyCost ::: ammount of enegry spent by each agent each timestep.#
#nAgents=100;energyCost=9;maxEnergy=100;resourceGrowthRate=2;nSteps=1000;dimX=30;dimY=30;memory=FALSE;decisionType=c("greedy");plot=TRUE;verbose=TRUE#
main<-function(nAgents=100,energyCost=9,maxEnergy=100,resourceGrowthRate=2,#
               nSteps=1000,dimX=30,dimY=30,memory=FALSE,#
               decisionType=c("greedy","probabilistic"),#
               plot=TRUE,verbose=TRUE)#
    {#
        population=numeric() #placeholder for recording population size #
        resource=matrix(round(runif(dimX*dimY,0,maxEnergy)),nrow=dimX,ncol=dimY) #initialise resource scape#
        maxResource=resource #maximum possible resource value per cell#
        #initialise agents as a data.frame:#
        agents=data.frame(energy=rep(maxEnergy/2,nAgents),x=ceiling(runif(nAgents,0,dimX)),y=ceiling(runif(nAgents,0,dimX)))#
#
        #Create cognitive map list in case of memory#
           if(memory==TRUE)#
               {#
                cognitiveMaps=vector("list",length=nAgents)#
                for (x in 1:nAgents){cognitiveMaps[[x]]=matrix(NA,nrow=dimX,ncol=dimY)}#
               }#
#
        #Start of the actual simulation##
        if(verbose==TRUE){pb <- txtProgressBar(min = 1, max = nSteps, style = 3)}#
#
        for (t in 1:nSteps)#
            {#
#
                #STEP 1: Observe, Move, and Collect Energy##
                newOrder=sample(1:nrow(agents)) #
                agents=agents[newOrder,]  #shuffle agent order#
                if(memory==TRUE){cognitiveMaps=cognitiveMaps[newOrder]}  #shuffle also cognitive map list#
                for (a in 1:nrow(agents))#
                            {#
                                #agents move#
                                if (memory==FALSE)#
                                    {    #
                                        agents[a,2:3]=neighbourhood(xcor=agents[a,2],ycor=agents[a,3],#
                                                  xLimit=c(1,dimX),yLimit=c(1,dimY),#
                                                  resourceMatrix=resource,type=decisionType)#
                                    }#
#
                                if (memory==TRUE)#
                                    {#
                                        #agents learn and move#
                                        tmp=getEnvironmentAndMove(xcor=agents[a,2],ycor=agents[a,3],#
                                            xLimit=c(1,dimX),yLimit=c(1,dimY),#
                                            resourceMatrix=resource,type=decisionType,myMap=cognitiveMaps[[a]])#
                                        cognitiveMaps[[a]]=tmp[[1]]#
                                        agents[a,2:3]=tmp[[2]]#
                                    }#
                                #agents consume#
                                collection=maxEnergy-agents[a,1]#
                                if(collection<=resource[agents[a,2],agents[a,3]])#
                                    {resource[agents[a,2],agents[a,3]]= resource[agents[a,2],agents[a,3]]-collection}#
                                if(collection>resource[agents[a,2],agents[a,3]])#
                                    {collection=resource[agents[a,2],agents[a,3]]#
                                     resource[agents[a,2],agents[a,3]]=0}#
                                agents[a,1]=collection+agents[a,1]#
                            }#
                #STEP 2: Reproduce##
                if(any(agents$energy==maxEnergy))#
                    {#
                        mothers=which(agents[,1]==maxEnergy)#
                        agents[mothers,1]=agents[mothers,1]/2#
                        agents<-rbind(agents,agents[mothers,])#
                        if(memory==TRUE){cognitiveMaps<-c(cognitiveMaps,cognitiveMaps[mothers])}#
                    }#
#
                #STEP 3: Spend Energy##
                agents$energy=agents$energy-energyCost#
                #STEP 4: Death##
                if(any(agents$energy<=0))#
                    {#
                      death=which(agents[,1]<=0)#
                      if(length(death)==nrow(agents))#
                            {#
                                agents=agents[-death,]#
                                print("extinction!")#
                                return(population)#
                            }#
                       agents=agents[-death,]#
                       if(memory==TRUE){cognitiveMaps=cognitiveMaps[-death]} #remove relevant cognitive maps#
                    }#
#
                #STEP 5: Resource Growth##
                resource=resource+resourceGrowthRate#
                index=which((resource-maxResource)>0,arr.ind=TRUE)#
                resource[index]=maxResource[index]#
                #Record Population Size:#
                population[t]=nrow(agents)#
                #Optional Plot Function##
                if(plot==TRUE)#
                    {#
                        par(mfrow=c(1,2))#
                        plot(1:t,population[1:t],type="l",xlab="time",ylab="population",#
                             main=paste("Avg.Energy=",round(mean(agents$energy),2)))#
                        image(x=1:dimX,y=1:dimY,z=resource,main=paste("Avg.Resource=",round(mean(resource),2)),zlim=c(0,maxEnergy))#
                        points(agents$x,agents$y,pch=20,cex=2)#
                    }#
#
                if(verbose==TRUE){setTxtProgressBar(pb, t)}#
            }#
        if(verbose==TRUE){close(pb)}#
        return(population)#
    }#
#utility functions ##
neighbourhood<-function(xcor,ycor,xLimit,yLimit,resourceMatrix,type=c("greedy","probabilistic"))#
{#
step=c(-1,0,1)#
xcor1=xcor+step#
ycor1=ycor+step#
address=expand.grid(x=xcor1,y=ycor1)#
noMove=address[5,]#
#
if(sum((address$x<xLimit[1]|address$x>xLimit[2]),na.rm=TRUE)>0){address[which(address$x<xLimit[1]|address$x>xLimit[2]),]=NA}#
if(sum((address$y<yLimit[1]|address$y>yLimit[2]),na.rm=TRUE)>0){address[which(address$y<yLimit[1]|address$y>yLimit[2]),]=NA}#
destinationResource=apply(address,1,function(x,y){#
    if(!is.na(x[1]))#
        {return(y[x[1],x[2]])}#
    if(is.na(x[1]))#
        return(NA)},y=resourceMatrix)#
#
if (all(destinationResource==0,na.rm=TRUE)) {return(noMove)}#
else {#
#
    if(type=="greedy")#
        {#
            goto=which(destinationResource==max(destinationResource,na.rm=TRUE))#
            if(length(goto)>1){goto=sample(goto,size=1)}#
            finaladdress=address[goto,]#
        }#
    if(type=="probabilistic")#
        {#
            destinationResource[which(is.na(destinationResource))]=0#
            goto=sample(1:9,size=1,prob=destinationResource)#
            if(length(goto)>1){goto=sample(goto,size=1)}#
            finaladdress=address[goto,]#
        }#
    return(finaladdress)#
      }#
}#
getEnvironmentAndMove<-function(xcor,ycor,xLimit,yLimit,resourceMatrix,myMap,type=c("greedy","probabilistic"))#
    {#
        step=c(-1,0,1)#
        xcor1=xcor+step#
        ycor1=ycor+step#
        address=expand.grid(x=xcor1,y=ycor1)#
        noMove=address[5,]#
        if(sum((address$x<xLimit[1]|address$x>xLimit[2]),na.rm=TRUE)>0)#
            {address[which(address$x<xLimit[1]|address$x>xLimit[2]),]=NA}#
        if(sum((address$y<yLimit[1]|address$y>yLimit[2]),na.rm=TRUE)>0)#
            {address[which(address$y<yLimit[1]|address$y>yLimit[2]),]=NA}#
        if(any(is.na(address$x))){address=address[-which(is.na(address$x)),]}#
        for (x in 1:9)#
            {#
                past=myMap[address[x,1],address[x,2]]#
                current=resourceMatrix[address[x,1],address[x,2]]#
                if(is.na(past)){myMap[address[x,1],address[x,2]]=current}#
                else if (!is.na(past)){myMap[address[x,1],address[x,2]]=c(past+current)/2}#
            }#
        destinationResource=apply(address,1,function(x,y){return(y[x[1],x[2]])}#
           ,y=myMap)#
        if (all(destinationResource==0,na.rm=TRUE)){return(list(myMap,noMove))}#
        else {#
        if(type=="greedy")#
            {#
                goto=which(destinationResource==max(destinationResource,na.rm=TRUE))#
                if(length(goto)>1){goto=sample(goto,size=1)}#
                finaladdress=address[goto,]#
            }#
        if(type=="probabilistic")#
            {#
                destinationResource[which(is.na(destinationResource))]=0#
                if (all(destinationResource==0)){} #if all destinations are 0#
                goto=sample(1:nrow(address),size=1,prob=destinationResource)#
                if(length(goto)>1){goto=sample(goto,size=1)}#
                finaladdress=address[goto,]#
            }#
        return(list(myMap,finaladdress))#
            }#
    }
#Example#
#param<-data.frame(nAgents=round(runif(10,1,200)),#
#                  dimX=30,dimY=30,#
#                  resourceGrowthRate=2,maxEnergy=100,energyCost=9,#
#                  nSteps=5,decisionType="greedy",memory=TRUE,#
#                  nRuns=1,stringsAsFactors=FALSE)#
decisionMakingExecuter<-function(param,allSteps=FALSE)#
{#
#
    runCounter=0#
    nAgentsRes=NA#
    run=NA#
    nSteps=NA#
    pb <- txtProgressBar(min = 1, max = nrow(param), style = 3)#
    for (x in 1:nrow(param))#
        {#
            for (y in 1:param$nRuns[x])#
                {#
                    tmp<-main(nAgents=param$nAgents[x],#
                              dimX=param$dimX[x],dimY=param$dimY[x],#
                              energyCost=param$energyCost[x],#
                              maxEnergy=param$maxEnergy[x],#
                              resourceGrowthRate=param$resourceGrowthRate[x],#
                              nSteps=param$nSteps[x],#
                              memory=param$memory[x],#
                              decisionType=param$decisionType[x],#
                              plot=FALSE,verbose=FALSE)#
                    runCounter=runCounter+1#
                    if (allSteps==TRUE)#
                        {#
                        run=c(run,rep(runCounter,length(tmp)))#
                        nAgentsRes=c(nAgentsRes,tmp)#
                        nSteps=c(nSteps,1:length(tmp))#
                        }#
                     if (allSteps==FALSE)#
                        {#
                        run=c(run,runCounter)#
                        nAgentsRes=c(nAgentsRes,tmp[length(tmp)])#
                        }#
                }#
            setTxtProgressBar(pb, x)#
        }#
    close(pb)#
    nAgentsRes=nAgentsRes[-1]#
    run=run[-1]#
    if (allSteps==TRUE)#
        {#
            nSteps=nSteps[-1]#
            result=data.frame(run=run,numberOfAgents=nAgentsRes,#
                nAgents=rep(param$nAgent,param$nRuns*param$nSteps),#
                dimX=rep(param$dimX,param$nRuns*param$nSteps),#
                dimY=rep(param$dimY,param$nRuns*param$nSteps),#
                energyCost=rep(param$energyCost,param$nRuns*param$nSteps),#
                resourceGrowthRate=rep(param$resourceGrowthRate,param$nRuns*param$nSteps),                #
                maxEnergy=rep(param$maxEnergy,param$nRuns*param$nSteps),#
                decisionType=rep(param$decisionType,param$nRuns*param$nSteps),#
                memory=rep(param$memory,param$nRuns*param$nSteps),#
                nSteps=nSteps)#
        }#
    if (allSteps==FALSE)#
        {#
            result=data.frame(run=run,finalNumAgents=nAgentsRes,#
                nAgents=rep(param$nAgent,param$nRuns),#
                dimX=rep(param$dimX,param$nRuns),#
                dimY=rep(param$dimY,param$nRuns),#
                energyCost=rep(param$energyCost,param$nRuns),#
                resourceGrowthRate=rep(param$resourceGrowthRate,param$nRuns),#
                maxEnergy=rep(param$maxEnergy,param$nRuns),               #
                decisionType=rep(param$decisionType,param$nRuns),#
                memory=rep(param$memory,param$nRuns),#
                nSteps=rep(param$nSteps,param$nRuns))#
#
        }#
return(result)#
#
}
Args=1
set.seed(Args)
param<-data.frame(nAgents=round(runif(1,1,200)),#
                  dimX=30,dimY=30,#
                  resourceGrowthRate=2,maxEnergy=100,energyCost=9,#
                  nSteps=5,decisionType=rep(c("greedy","probabilistic"),2),memory=c(rep(TRUE,2),rep(FALSE,2)),#
                  nRuns=1,stringsAsFactors=FALSE)
param
res=decisionMakingExecuter(param,allSteps=TRUE)
res$seed=Args
res
res=data.frame(nAgents=res$nAgents,numberOfAgents=res$numberOfAgents,decisionType=res$decisionType,memory=res$memory,seed=Args)
res
res=data.frame(nAgents=res$nAgents,numberOfAgents=res$numberOfAgents,decisionType=res$decisionType,memory=res$memory,seed=Args,nSteps=res$nSteps)
res=data.frame(nAgents=res$nAgents,numberOfAgents=res$numberOfAgents,decisionType=res$decisionType,memory=res$memory,seed=Args)
res
res=data.frame(nAgents=res$nAgents,numberOfAgents=res$numberOfAgents,decisionType=res$decisionType,memory=res$memory,seed=Args,steps=res$nSteps)
res
res=decisionMakingExecuter(param,allSteps=TRUE)
res
res$seed=Args#
name<-paste("./res",Args,".csv",sep="")#
res=data.frame(nAgents=res$nAgents,numberOfAgents=res$numberOfAgents,decisionType=res$decisionType,memory=res$memory,seed=Args,steps=res$nSteps)
res
data<-read.csv("~/github/XaviModels/modelling_sss/src/R/results/experiment1Complete.csv",col.names=c("initialNAgents","nAgents","type","memory","seed"))
data<-read.csv("~/github/models/modelling_sss/src/R/results/experiment1Complete.csv",col.names=c("initialNAgents","nAgents","type","memory","seed"))
data<-read.csv("~/github/models/modelling_sss/src/R/results/experiment1Complete.csv")
data[1:10,]
data<-read.csv("~/github/models/modelling_sss/src/R/results/experiment1Complete.csv",col.names=c("id","initialNAgents","nAgents","type","memory","seed"))
data<-read.csv("~/github/models/modelling_sss/src/R/results/experiment1Complete.csv",col.names=c("id","initialNAgents","nAgents","type","memory","seed","steps"))
data[1:4,]
summary(data)
nrow(data)
?data
?write.csv
data<-read.csv("~/github/models/modelling_sss/src/R/results/experiment1Complete.csv",col.names=c("id","initialNAgents","nAgents","type","memory","seed","steps"))
nrow(data)
?read.csv
data<-read.csv("~/github/models/modelling_sss/src/R/results/experiment1Complete.csv",col.names=c("id","initialNAgents","nAgents","type","memory","seed","steps"),header=F)
nrow(data)
data<-read.csv("~/github/models/modelling_sss/src/R/results/experiment1Complete.csv",col.names=c("id","initialNAgents","nAgents","type","memory","seed","steps"),header=F)
colnames(data)
p1<-qplot(data = subset(data,type=="greedy"& memory==TRUE), nAgents, steps) + ggtitle("Greedy & Memory")
library(ggplot2)
p1<-qplot(data = subset(data,type=="greedy"& memory==TRUE), nAgents, steps) + ggtitle("Greedy & Memory")
plot(p1)
p1<-qplot(data = subset(data,type=="greedy"& memory==TRUE), steps,nAgents) + ggtitle("Greedy & Memory")
plot(p1)
data[1:10,]
rep(1:10,2)
rep(1,2)
rep(1,1000)
rep(1:10,1:10)
rep(1:10,10)
rep(1:10,rep(1:10))
rep(1:5,rep(1:5))
rep(1:5,5)
?rep
rep.int(1:5,5)
rep.int(1:5,rep(5,5))
rep(1:5,rep(5,5))
-rep(1:400,rep(400,1000))
rep(1:400,rep(400,1000))
rep(1:10,rep(2,1))
rep(1:10,rep(2,2))
rep(3,1)
rep(1:400,rep(1000,400))
data$run<-rep(1:400,rep(1000,400))
ggplot(data = subset(data,type=="greedy"& memory==TRUE), steps,nAgents,group=data$run) + geom_line(aes(group=1)) +ggtitle("Greedy & Memory")
data[1,]
ggplot(data = subset(data,type=="greedy"& memory==TRUE),aes(x=steps, y=nAgents, group=run))) + geom_line(aes(group=run)) +ggtitle("Greedy & Memory")
ggplot(data = subset(data,type=="greedy"& memory==TRUE),aes(x=steps, y=nAgents, group=run)) + geom_line(aes(group=run)) +ggtitle("Greedy & Memory")
p2<-ggplot(data = subset(data,type=="greedy"& memory==FALSE),aes(x=steps, y=nAgents, group=run)) + geom_line(aes(group=run)) +ggtitle("Greedy & NoMemory")
plot(p2)
p1<-ggplot(data = subset(data,type=="greedy"& memory==TRUE),aes(x=steps, y=nAgents, group=run)) + geom_line(aes(group=run)) +ggtitle("Greedy & Memory")#
p2<-ggplot(data = subset(data,type=="greedy"& memory==FALSE),aes(x=steps, y=nAgents, group=run)) + geom_line(aes(group=run)) +ggtitle("Greedy & NoMemory")#
p3<-ggplot(data = subset(data,type=="probabilistic"& memory==TRUE),aes(x=steps, y=nAgents, group=run)) + geom_line(aes(group=run)) +ggtitle("Probabilistic & Memory")#
p4<-ggplot(data = subset(data,type=="probabilistic"& memory==FALSE),aes(x=steps, y=nAgents, group=run)) + geom_line(aes(group=run)) +ggtitle("Probabilistic & NoMemory")
multiplot(p1, p3, p2, p4, cols=2)
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }
}
multiplot <- function(..., plotlist=NULL, file, cols=1, layout=NULL) {#
  require(grid)#
#
  # Make a list from the ... arguments and plotlist#
  plots <- c(list(...), plotlist)#
#
  numPlots = length(plots)#
#
  # If layout is NULL, then use 'cols' to determine layout#
  if (is.null(layout)) {#
    # Make the panel#
    # ncol: Number of columns of plots#
    # nrow: Number of rows needed, calculated from # of cols#
    layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),#
                    ncol = cols, nrow = ceiling(numPlots/cols))#
  }#
#
 if (numPlots==1) {#
    print(plots[[1]])#
#
  } else {#
    # Set up the page#
    grid.newpage()#
    pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))#
#
    # Make each plot, in the correct location#
    for (i in 1:numPlots) {#
      # Get the i,j matrix positions of the regions that contain this subplot#
      matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))#
#
      print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,#
                                      layout.pos.col = matchidx$col))#
    }#
  }#
}
multiplot(p1, p3, p2, p4, cols=2)
dev.print(device=png,"./Desktop/experiment1_110315.png")
dev.print(device=png,"./Desktop/experiment1_110315.png",width=100,height=60)
dev.print(device=png,"./Desktop/experiment1_110315.png",width=1000,height=600)
dev.print(device=png,"./Desktop/experiment1_110315.png",width=900,height=600)
dev.print(device=png,"./Desktop/experiment1_110315.png",width=800,height=600)
source('~/github/models/modelling_sss/src/R/results/plotUtility.R', chdir = TRUE)
rm(list=ls9)
rm(list=ls())
library(ggplot2)#
source("~/github/models/modelling_sss/src/R/results/plotUtility.R")#
# Experiment 1#
data<-read.csv("~/github/models/modelling_sss/src/R/results/experiment1Complete.csv",col.names=c("id","initialNAgents","nAgents","type","memory","seed","steps"),header=F)#
#
#generate run Number#
data$run<-rep(1:400,rep(1000,400))#
p1<-ggplot(data = subset(data,type=="greedy"& memory==TRUE),aes(x=steps, y=nAgents, group=run)) + geom_line(aes(group=run)) +ggtitle("Greedy & Memory")#
p2<-ggplot(data = subset(data,type=="greedy"& memory==FALSE),aes(x=steps, y=nAgents, group=run)) + geom_line(aes(group=run)) +ggtitle("Greedy & NoMemory")#
p3<-ggplot(data = subset(data,type=="probabilistic"& memory==TRUE),aes(x=steps, y=nAgents, group=run)) + geom_line(aes(group=run)) +ggtitle("Probabilistic & Memory")#
p4<-ggplot(data = subset(data,type=="probabilistic"& memory==FALSE),aes(x=steps, y=nAgents, group=run)) + geom_line(aes(group=run)) +ggtitle("Probabilistic & NoMemory")#
#
multiplot(p1, p3, p2, p4, cols=2)#
dev.print(device=png,"~/github/models/modelling_sss/src/R/results/experiment1_110315.png",width=800,height=600)
# Experiment 2#
data<-read.csv("~/github/models/modelling_sss/src/R/results/experiment2Complete.csv",col.names=c("run","type","diversity","nAgents"),header=FALSE)#
#
library(ggplot2)#
p1<-qplot(data = subset(data,type=="vertical"), nAgents, diversity)+geom_smooth(method = "loess", size = 1.5) + coord_cartesian(ylim = c(0, 1)) + ggtitle("Vertical") + scale_y_continuous("Simpson's Diversity") #
p2<-qplot(data = subset(data,type=="encounter"), nAgents, diversity)+geom_smooth(method = "loess", size = 1.5) + coord_cartesian(ylim = c(0, 1)) + ggtitle("Encounter") + scale_y_continuous("Simpson's Diversity") #
p3<-qplot(data = subset(data,type=="prestige"), nAgents, diversity)+geom_smooth(method = "loess", size = 1.5) + coord_cartesian(ylim = c(0, 1)) + ggtitle("Prestige") + scale_y_continuous("Simpson's Diversity") #
p4<-qplot(data = subset(data,type=="conformist"), nAgents, diversity)+geom_smooth(method = "loess", size = 1.5) + coord_cartesian(ylim = c(0, 1)) + ggtitle("Conformist") + scale_y_continuous("Simpson's Diversity") #
multiplot(p1, p3, p2, p4, cols=2) #see below for multiplot code
dev.print(device=png,"~/github/models/modelling_sss/src/R/results/experiment1_110315.png",width=800,height=600)
dev.print(device=png,"~/github/models/modelling_sss/src/R/results/experiment2_110315.png",width=800,height=600)
data<-read.csv("~/github/models/modelling_sss/src/R/results/experiment1Complete.csv",col.names=c("id","initialNAgents","nAgents","type","memory","seed","steps"),header=F)#
#
#generate run Number#
data$run<-rep(1:400,rep(1000,400))#
p1<-ggplot(data = subset(data,type=="greedy"& memory==TRUE),aes(x=steps, y=nAgents, group=run)) + geom_line(aes(group=run)) +ggtitle("Greedy & Memory")#
p2<-ggplot(data = subset(data,type=="greedy"& memory==FALSE),aes(x=steps, y=nAgents, group=run)) + geom_line(aes(group=run)) +ggtitle("Greedy & NoMemory")#
p3<-ggplot(data = subset(data,type=="probabilistic"& memory==TRUE),aes(x=steps, y=nAgents, group=run)) + geom_line(aes(group=run)) +ggtitle("Probabilistic & Memory")#
p4<-ggplot(data = subset(data,type=="probabilistic"& memory==FALSE),aes(x=steps, y=nAgents, group=run)) + geom_line(aes(group=run)) +ggtitle("Probabilistic & NoMemory")#
#
multiplot(p1, p3, p2, p4, cols=2)#
dev.print(device=png,"~/github/models/modelling_sss/src/R/results/experiment1_110315.png",width=800,height=600)
setwd("~/github/culturalincubators/")
system("ls")
plot(1:150,RC(k=1:150,c=0,z=1),type="l",xlab="k",ylab="P(loss)",ylim=c(0,0.5),main=c("Random Copying with c=0"))#
lines(1:150,RC(k=1:150,c=0,z=0.5),lty=2)#
lines(1:150,RC(k=1:150,c=0,z=0.1),lty=3)#
legend("topright",legend=c("z=1","z=0.5","z=0.1"),lty=1:3)
load("/Users/enryu/github/culturalincubators/explorations/explorations1.RData")
plot(1:150,RC(k=1:150,c=0,z=1),type="l",xlab="k",ylab="P(loss)",ylim=c(0,0.5),main=c("Random Copying with c=0"))#
lines(1:150,RC(k=1:150,c=0,z=0.5),lty=2)#
lines(1:150,RC(k=1:150,c=0,z=0.1),lty=3)#
legend("topright",legend=c("z=1","z=0.5","z=0.1"),lty=1:3)
plot(1:150,RC(k=1:150,c=0,z=1),type="l",xlab="k",ylab="P(loss)",ylim=c(0,0.5),main=c("Random Copying with c=0"))#
lines(1:150,RC(k=1:150,c=0,z=0.5),lty=2)#
lines(1:150,RC(k=1:150,c=0,z=0.1),lty=3)#
legend("topright",legend=c("z=1","z=0.5","z=0.1"),lty=1:3)
dev.print(device=png,"./explorations/figures/fig1.png",width=400,width=400)
dev.print(device=png,"./explorations/figures/fig1.png",width=400,height=400)
plot(1:150,RC(k=1:150,c=0,z=1),type="l",xlab="k",ylab="P(loss)",ylim=c(0,0.5),main="Random Copying with z=1")#
lines(1:150,RC(k=1:150,c=0.001,z=1),lty=2)#
lines(1:150,RC(k=1:150,c=0.01,z=1),lty=3)#
legend("topright",legend=c("c=0","c=0.001","c=0.01"),lty=1:3)
dev.print(device=png,"./explorations/figures/fig2.png",width=400,height=400)
plot(1:150,pLoss1.pw,type="l",xlab="k",ylab="P(loss)",ylim=c(0,0.5),main="Random Copying with Evaluation, z=1,c=0,sigma=1")#
lines(1:150,pLoss2.pw,lty=2)#
lines(1:150,pLoss3.pw,lty=3)#
legend("topright",legend=c(expression(paste(g[i],"=1",sep="")),expression(paste(g[i],"=2",sep="")),expression(paste(g[i],"=3",sep=""))),lty=1:3)
dev.print(device=png,"./explorations/figures/fig3.png",width=400,height=400)
plot(1:150,pLoss1.pwS,type="l",xlab="k",ylab="P(loss)",ylim=c(0,0.5),main="Random Copying with Evaluation, z=1,c=0,gi=2,gj=1")#
lines(1:150,pLoss2.pwS,lty=2)#
lines(1:150,pLoss3.pwS,lty=3)#
legend("topright",legend=c(expression(paste(sigma,"=1",sep="")),expression(paste(sigma,"=2",sep="")),expression(paste(sigma,"=3",sep=""))),lty=1:3)
dev.print(device=png,"./explorations/figures/fig4.png",width=400,height=400)
plot(1:150,pLoss1.cb,type="l",xlab="k",ylab="P(loss)",ylim=c(0.2,1),main="Copy-the-Best, c=0,z=1,gj=1,sigma=1")#
lines(1:150,pLoss2.cb,lty=2)#
lines(1:150,pLoss3.cb,lty=3)#
legend("bottomright",legend=c(expression(paste(g[i],"=1",sep="")),expression(paste(g[i],"=2",sep="")),expression(paste(g[i],"=3",sep=""))),lty=1:3)
dev.print(device=png,"./explorations/figures/fig5.png",width=400,height=400)
plot(1:150,pLoss1.cbS,type="l",xlab="k",ylab="P(loss)",ylim=c(0.2,1),main="Copy-the-Best, c=0,z=1,gj=1,gi=2")#
lines(1:150,pLoss2.cbS,lty=2)#
lines(1:150,pLoss3.cbS,lty=3)#
legend("right",legend=c(expression(paste(sigma,"=1",sep="")),expression(paste(sigma,"=2",sep="")),expression(paste(sigma,"=3",sep=""))),lty=1:3)
dev.print(device=png,"./explorations/figures/fig6.png",width=400,height=400)
plot(1:150,pLoss1.cbC,type="l",xlab="k",ylab="P(loss)",ylim=c(0,0.8),main="Copy-the-Best, c=0.01,z=1,sigma=1,gj=1")#
lines(1:150,pLoss2.cbC,lty=2)#
lines(1:150,pLoss3.cbC,lty=3)#
legend("topright",legend=c(expression(paste(g[i],"=1",sep="")),expression(paste(g[i],"=2",sep="")),expression(paste(g[i],"=3",sep=""))),lty=1:3)
dev.print(device=png,"./explorations/figures/fig7a.png",width=400,height=400)
plot(1:150,pLoss1.cbClo,type="l",xlab="k",ylab="P(loss)",ylim=c(0,1),main="Copy-the-Best, c=0.001,z=1,sigma=1,gj=1")#
lines(1:150,pLoss2.cbClo,lty=2)#
lines(1:150,pLoss3.cbClo,lty=3)#
legend("bottomright",legend=c(expression(paste(g[i],"=1",sep="")),expression(paste(g[i],"=2",sep="")),expression(paste(g[i],"=3",sep=""))),lty=1:3)
dev.print(device=png,"./explorations/figures/fig7b.png",width=400,height=400)
source("./src/SpatialModel.R")#
#
N=1000#
k=100#
x<-runif(N)#
y<-runif(N)#
distMatrix<-as.matrix(dist(cbind(x,y)))#
neighbours=matrixGenerator(distMatrix=distMatrix,k=k)#
#
#Define Sample pools#
i=subset(locations,x>0.35&x<0.45&y>0.35&y<0.45)$id[1]#
j=subset(locations,x>0.45&x<0.65&y>0.40&y<0.60)$id[1]#
#
shared.pool=which(apply(neighbours[c(i,j),],2,sum)==2)#
pool.j=which(neighbours[j,]==1)#
pool.j=pool.j[-which(pool.j%in%shared.pool)]#
pool.i=which(neighbours[i,]==1)#
pool.i=pool.i[-which(pool.i%in%shared.pool)]#
rest=c(1:N)[-c(pool.j,pool.i,shared.pool)]#
#plot#
plot(x[rest],y[rest],pch=20,col=rgb(0,0,0,0.05),ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[i],y[i],pch=15,col="red")#
points(x[j],y[j],pch=15,col=rgb(0,0,1,1))#
#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.2))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.2))#
points(x[shared.pool],y[shared.pool],pch=20,col=rgb(0,1,0,0.2))
source("./src/SpatialModel.R")
N=1000#
k=100#
x<-runif(N)#
y<-runif(N)#
distMatrix<-as.matrix(dist(cbind(x,y)))#
neighbours=matrixGenerator(distMatrix=distMatrix,k=k)
#Define Sample pools#
i=subset(locations,x>0.35&x<0.45&y>0.35&y<0.45)$id[1]#
j=subset(locations,x>0.45&x<0.65&y>0.40&y<0.60)$id[1]#
#
shared.pool=which(apply(neighbours[c(i,j),],2,sum)==2)#
pool.j=which(neighbours[j,]==1)#
pool.j=pool.j[-which(pool.j%in%shared.pool)]#
pool.i=which(neighbours[i,]==1)#
pool.i=pool.i[-which(pool.i%in%shared.pool)]#
rest=c(1:N)[-c(pool.j,pool.i,shared.pool)]
N=1000#
k=100#
x<-runif(N)#
y<-runif(N)#
distMatrix<-as.matrix(dist(cbind(x,y)))#
neighbours=matrixGenerator(distMatrix=distMatrix,k=k)#
locations<-data.frame(x=x,y=y)#
#
#Define Sample pools#
i=subset(locations,x>0.35&x<0.45&y>0.35&y<0.45)$id[1]#
j=subset(locations,x>0.45&x<0.65&y>0.40&y<0.60)$id[1]#
#
shared.pool=which(apply(neighbours[c(i,j),],2,sum)==2)#
pool.j=which(neighbours[j,]==1)#
pool.j=pool.j[-which(pool.j%in%shared.pool)]#
pool.i=which(neighbours[i,]==1)#
pool.i=pool.i[-which(pool.i%in%shared.pool)]#
rest=c(1:N)[-c(pool.j,pool.i,shared.pool)]#
#plot#
plot(x[rest],y[rest],pch=20,col=rgb(0,0,0,0.05),ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[i],y[i],pch=15,col="red")#
points(x[j],y[j],pch=15,col=rgb(0,0,1,1))#
#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.2))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.2))#
points(x[shared.pool],y[shared.pool],pch=20,col=rgb(0,1,0,0.2))
N=1000#
k=100#
x<-runif(N)#
y<-runif(N)#
distMatrix<-as.matrix(dist(cbind(x,y)))#
neighbours=matrixGenerator(distMatrix=distMatrix,k=k)#
locations<-data.frame(x=x,y=y)
N=1000#
k=100#
x<-runif(N)#
y<-runif(N)#
distMatrix<-as.matrix(dist(cbind(x,y)))#
neighbours=matrixGenerator(distMatrix=distMatrix,k=k)#
locations<-data.frame(id=1:N,x=x,y=y)#
#
#Define Sample pools#
i=subset(locations,x>0.35&x<0.45&y>0.35&y<0.45)$id[1]#
j=subset(locations,x>0.45&x<0.65&y>0.40&y<0.60)$id[1]#
#
shared.pool=which(apply(neighbours[c(i,j),],2,sum)==2)#
pool.j=which(neighbours[j,]==1)#
pool.j=pool.j[-which(pool.j%in%shared.pool)]#
pool.i=which(neighbours[i,]==1)#
pool.i=pool.i[-which(pool.i%in%shared.pool)]#
rest=c(1:N)[-c(pool.j,pool.i,shared.pool)]#
#plot#
plot(x[rest],y[rest],pch=20,col=rgb(0,0,0,0.05),ylim=c(0,1),xlim=c(0,1),xlab="x",ylab="y")#
points(x[i],y[i],pch=15,col="red")#
points(x[j],y[j],pch=15,col=rgb(0,0,1,1))#
#
points(x[pool.i],y[pool.i],pch=20,col=rgb(1,0,0,0.2))#
points(x[pool.j],y[pool.j],pch=20,col=rgb(0,0,1,0.2))#
points(x[shared.pool],y[shared.pool],pch=20,col=rgb(0,1,0,0.2))
dev.print(device=png,"./figures/testFigures/figSpatial.png",width=400,height=400)
#Read Data (preliminary data with slightly less than 30,000 runs each)#
model1<-read.csv("./data/combinedResultsModel1.csv",col.names=c("id","sigma","z","mu","k","median","mean"))#
random1<-read.csv("./data/combinedResultsRandom1.csv",col.names=c("id","sigma","z","mu","k","median","mean"))#
weighted1<-read.csv("./data/combinedResultsWeighted1.csv",col.names=c("id","sigma","z","mu","k","median","mean"))#
#
# Define Break points for a 2 x 5 figure#
X<-seq(0,3,length.out=11)#
#
# Define Parameter Settings#
par(mfrow=c(2,5))#
par(mar=c(3,3,1,1))#
#
# Generate Color Ramp Function#
cm<-colorRampPalette(c("lightpink", "red"))#
cr<-colorRampPalette(c("khaki1", "orange"))#
cc<-colorRampPalette(c("lightblue", "darkblue"))#
#
# Define Titles#
title<-vector("list",length=c(length(X)-1))#
title[1]=expression(paste("0<",sigma,"<0.3"))#
title[2]=expression(paste("0.3<",sigma,"<0.6"))#
title[3]=expression(paste("0.6<",sigma,"<0.9"))#
title[4]=expression(paste("0.9<",sigma,"<1.2"))#
title[5]=expression(paste("1.2<",sigma,"<1.5"))#
title[6]=expression(paste("1.5<",sigma,"<1.8"))#
title[7]=expression(paste("1.8<",sigma,"<2.1"))#
title[8]=expression(paste("2.1<",sigma,"<2.4"))#
title[9]=expression(paste("2.4<",sigma,"<2.7"))#
title[10]=expression(paste("2.7<",sigma,"<3"))#
# plotting for loop#
for (x in 1:c(length(X)-1))#
    {#
# subset data based         #
smdata=subset(model1,sigma>X[x]&sigma<c(X[x+1]))#
col <- as.numeric(cut(smdata$sigma, quantile(smdata$sigma,prob=seq(0,1,0.1)),labels = 1:10))#
colours<-adjustcolor(cm(10),alpha.f=1)[col]#
plot(mean~k,pch=20,col=colours,ylab=expression(bar(g)),xlab="k",data=smdata,main=title[x],axes=F)#
axis(side=1,at=seq(0,500,100),labels=seq(0,500,100),padj=-1,tcl=-0.4)#
axis(side=2,padj=1,tcl=-0.4)#
mtext(side=1,text="k",line=1.3)#
mtext(side=2,text=expression(bar(g)),line=1.5,las=2)#
box()#
#
scdata=subset(weighted1,sigma>X[x]&sigma<c(X[x+1]))#
col <- as.numeric(cut(scdata$sigma, quantile(scdata$sigma,prob=seq(0,1,0.1)),labels = 1:10))#
colours<-adjustcolor(cc(10),alpha.f=1)[col]#
points(mean~k,pch=20,col=colours,data=scdata)#
#
srdata=subset(random1,sigma>X[x]&sigma<c(X[x+1]))#
col <- as.numeric(cut(srdata$sigma, quantile(srdata$sigma,prob=seq(0,1,0.1)),labels = 1:10))#
colours<-adjustcolor(cr(10),alpha.f=1)[col]#
points(mean~k,pch=20,col=colours,data=srdata)
}
par(mfrow=c(2,5))#
par(mar=c(3,3,1,1))#
#
# Generate Color Ramp Function#
cm<-colorRampPalette(c("lightpink", "red"))#
cr<-colorRampPalette(c("khaki1", "orange"))#
cc<-colorRampPalette(c("lightblue", "darkblue"))#
#
# Define Titles#
title<-vector("list",length=c(length(X)-1))#
title[1]=expression(paste("0<",sigma,"<0.3"))#
title[2]=expression(paste("0.3<",sigma,"<0.6"))#
title[3]=expression(paste("0.6<",sigma,"<0.9"))#
title[4]=expression(paste("0.9<",sigma,"<1.2"))#
title[5]=expression(paste("1.2<",sigma,"<1.5"))#
title[6]=expression(paste("1.5<",sigma,"<1.8"))#
title[7]=expression(paste("1.8<",sigma,"<2.1"))#
title[8]=expression(paste("2.1<",sigma,"<2.4"))#
title[9]=expression(paste("2.4<",sigma,"<2.7"))#
title[10]=expression(paste("2.7<",sigma,"<3"))#
# plotting for loop#
for (x in 1:c(length(X)-1))#
    {#
# subset data based         #
smdata=subset(model1,sigma>X[x]&sigma<c(X[x+1]))#
col <- as.numeric(cut(smdata$sigma, quantile(smdata$sigma,prob=seq(0,1,0.1)),labels = 1:10))#
colours<-adjustcolor(cm(10),alpha.f=1)[col]#
plot(mean~k,pch=20,col=colours,ylab=expression(bar(g)),xlab="k",data=smdata,main=title[x],axes=F)#
axis(side=1,at=seq(0,500,100),labels=seq(0,500,100),padj=-1,tcl=-0.4)#
axis(side=2,padj=1,tcl=-0.4)#
mtext(side=1,text="k",line=1.3)#
mtext(side=2,text=expression(bar(g)),line=1.5,las=2)#
box()#
#
scdata=subset(weighted1,sigma>X[x]&sigma<c(X[x+1]))#
col <- as.numeric(cut(scdata$sigma, quantile(scdata$sigma,prob=seq(0,1,0.1)),labels = 1:10))#
colours<-adjustcolor(cc(10),alpha.f=1)[col]#
points(mean~k,pch=20,col=colours,data=scdata)#
#
srdata=subset(random1,sigma>X[x]&sigma<c(X[x+1]))#
col <- as.numeric(cut(srdata$sigma, quantile(srdata$sigma,prob=seq(0,1,0.1)),labels = 1:10))#
colours<-adjustcolor(cr(10),alpha.f=1)[col]#
points(mean~k,pch=20,col=colours,data=srdata)#
#
#lines(k,predict(fit,mdata.frame(k=k)),col="red",lwd=2)#
}
dev.print(device=png,"./figures/fig3.png",width=300*5,height=300*2)
250*5
dev.print(device=png,"./figures/fig3.png",width=250*5,height=300*2)
dev.print(device=png,"./figures/fig3.png",width=1250,height=550)
dev.print(device=png,"./figures/fig3.png",width=1250,height=500)
#Read Data (preliminary data with slightly less than 30,000 runs each)#
model2<-read.csv("./data/combinedResultsModel2.csv",col.names=c("id","sigma","z","mu","k","median","mean"))#
#random2<-read.csv("./data/incomplete/combinedResultsRandom1.csv",col.names=c("id","sigma","z","mu","k","median","mean"))#
#weighted2<-read.csv("./data/incomplete/combinedResultsWeighted1.csv",col.names=c("id","sigma","z","mu","k","median","mean"))#
layout(matrix(c(1,2,3),nrow=1,ncol=3),width=c(1,1,0.4))#
#
cc<-colorRampPalette(c("yellow","blue", "red"))#
hiSigma<-subset(model2,sigma>=2.5)#
loSigma<-subset(model2,sigma<=0.5)#
#
hiSigma$col <- as.numeric(cut(hiSigma$mean, quantile(hiSigma$mean,prob=seq(0,1,0.1)),labels = 1:10))#
loSigma$col <- as.numeric(cut(loSigma$mean, quantile(loSigma$mean,prob=seq(0,1,0.1)),labels = 1:10))#
#
plot(k~z,col=adjustcolor(cc(10),alpha.f=0.3)[loSigma$col],data=loSigma,pch=20,cex=1,cex.main=1.4,cex.lab=1.5,ylim=c(0,500),main=expression(paste(sigma,"<0.5")))#
plot(k~z,col=adjustcolor(cc(10),alpha.f=0.3)[hiSigma$col],data=hiSigma,pch=20,cex=1,cex.main=1.4,cex.lab=1.5,ylim=c(0,500),main=expression(paste("2.5<",sigma,"<3")))#
#
par(mar=c(3,3,3,3))#
plot(1,1,xlim=c(1,10),ylim=c(1,11), type='n', bty='n', xaxt='n', xlab='', yaxt='n', ylab='',main=expression(paste(bar(g)," percentile")))#
axis(2, at=seq(0,10,1),labels=paste(seq(0,100,10),"th",sep=""), las=1)#
for (i in 1:10) {#
    	rect(0,i-0.5,10,i+0.5,col=cc(10)[i], border=NA)#
    }
#Read Data (preliminary data with slightly less than 30,000 runs each)#
model2<-read.csv("./data/combinedResultsModel2.csv",col.names=c("id","sigma","z","mu","k","median","mean"))#
#random2<-read.csv("./data/incomplete/combinedResultsRandom1.csv",col.names=c("id","sigma","z","mu","k","median","mean"))#
#weighted2<-read.csv("./data/incomplete/combinedResultsWeighted1.csv",col.names=c("id","sigma","z","mu","k","median","mean"))#
layout(matrix(c(1,2,3),nrow=1,ncol=3),width=c(1,1,0.4))#
#
cc<-colorRampPalette(c("yellow","blue", "red"))#
hiSigma<-subset(model2,sigma>=2.5)#
loSigma<-subset(model2,sigma<=0.5)#
#
hiSigma$col <- as.numeric(cut(hiSigma$mean, quantile(hiSigma$mean,prob=seq(0,1,0.1)),labels = 1:10))#
loSigma$col <- as.numeric(cut(loSigma$mean, quantile(loSigma$mean,prob=seq(0,1,0.1)),labels = 1:10))#
#
plot(k~z,col=adjustcolor(cc(10),alpha.f=0.3)[loSigma$col],data=loSigma,pch=20,cex=1,cex.main=1.4,cex.lab=1.5,ylim=c(0,500),main=expression(paste(sigma,"<0.5")))#
plot(k~z,col=adjustcolor(cc(10),alpha.f=0.3)[hiSigma$col],data=hiSigma,pch=20,cex=1,cex.main=1.4,cex.lab=1.5,ylim=c(0,500),main=expression(paste("2.5<",sigma,"<3")))#
#
par(mar=c(3,3,3,3))#
plot(1,1,xlim=c(1,10),ylim=c(1,11), type='n', bty='n', xaxt='n', xlab='', yaxt='n', ylab='',main=expression(paste(bar(g)," percentile")))#
axis(2, at=seq(0,10,1),labels=paste(seq(0,100,10),"th",sep=""), las=1)#
for (i in 1:10) {#
    	rect(0,i-0.5,10,i+0.5,col=cc(10)[i], border=NA)#
    }
dev.print(device=png,"./figures/fig4.png",width=700,height=400)
dev.print(device=png,"./figures/fig4.png",width=700,height=300)
dev.print(device=png,"./figures/fig4.png",width=700,height=350)
